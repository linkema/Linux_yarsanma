进程：代码在资源集合的一次运行过程。
=code(1.线性地址（逻辑）不足可以采用间接索引多级指针 2.编程时使用逻辑地址（连续）3.词法分析;语法分析；功能段的划分4.文编译后的程序以ELF格式命名空间 
好处：便于移植和保护)
+pcb
+设备->设备列表(虚拟设备号|物理设备)+内存->ELF格式（内存地址映射表4g(1g系统（进程PCB+系统缓冲）3g可用)）+CPU->时间片+寄存器镜像
running:pcb
reading:pcb
code->TEXT r-x
data初始化后的数据->wr-
bss未初始化的数据->wr-
这三个块的地址固定
heap就是杂乱的页堆，所以需要一个精确的算法链表连接起来方便管理

#c打头的地址会导致PAGE fault
1.非法使用线性地址空间
2.stack和heap握手 栈溢出或者堆耗尽（递归）
	解决方法：代码优化，少用全局静态常量，留下足够的线性地址

段生命周期以及可见性
1.系统区是所的进程都可见（超全局）
2.TEXT区是同源进程共享，内存中只读（public）0X80480400
3.data+bss对进程中所有函数都可见（protected）
4.heap中的内容是从malloc开始调用free失效，或者进程终止(private)
5.stack frame->函数调用至终止(private)

系统中功能实现：1.电路（高频且简单，典型运用MMU，BIOS）2.代码

##电脑系统启动
CMOS中的BIOS自举-》初始化最小硬件环境stdin,stdout,stderr 64kb
-》bootloader找系统盘的主引导记录
-》0#进程 初始化程序进程运行剩余的硬件环境
-》1#进程 init进程初始化系统运行所需要的软件环境
（单道串行CPU出于实模式）
-》2#...
(保护模式，支持多道并发)

0号地址无法被使用

内存和IO中断成反比
内存大小要与CPU的寻址能力相匹配

系统启动CPU的工作模块
系统运行状态
CPU的工作模式
4级保护机制
0级全局运作 3级用户APP部分运作

标准I/O=系统缓冲+用户缓冲（先）
充分利用资源，共享内存区。

Linux无线程
用户级线程库-pthread
内核分配cpu的进程为单位
调度在用户空间实现（需要从用户态转换到核心态）

线程->多核CPU（由同一任务派生的亲缘线程，为同一任务工作因而可以共享大量资源，当进程切换时可以减少上下文信息的保存时间，从而提高运行速度）
程序编制时应划分为多个可并行的逻辑任务
局部变量进stack 代码-ELF-TEXT

/proc是一个观察内核实时状态的文件系统

进程间相互通信通过PIC相互转发

|管道文件在系统区中，所有关于进程的信息都放在系统区中（二级指针）

二进制：可执行文件，库文件，call文件核心转储

僵尸进程：父在子 先亡  子进程不回收资源成为僵尸进程 ！对策：1号进程init收养所有孤儿进程	守护、精灵进程1.开机运行2.后台运行3.提供系统报告  脱离上级关系

./程序名&->后台进行无需交互
